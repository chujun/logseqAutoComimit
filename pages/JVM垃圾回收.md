- 总体思路
  1. java对象内存是如何分配的？
  2. 如何判断一个对象是否该回收的“垃圾”？
  3. 什么时候进行垃圾回收？
  4. 如何进行垃圾回收？
  5. 垃圾回收效率:如何高效进行垃圾回收，同时尽可能小的影响应用程序？
  ![JVM垃圾回收.png](../assets/image_1654932154341_0.png)
  主要作用内存区域
  java堆是垃圾回收器主要作用区域
  ![堆空间结构.png](../assets/image_1654932510373_0.png)
- 对象内存分配
  TODO:cj 
  大部分情况，对象都会首先在新生代Eden区域分配
  对象新生代晋升到老年代的年龄阈值
  -XX:MaxTenuringThreshold 来设置默认值
- 判断对象是否”存活"
  ((6299ed85-5fab-4abb-ad7e-d901f1d30469)) 
  两种方法判断对象是否存活
	- 1. 引用计数法(Reference Counting)
	  定义:一个对象对应一个引用计数器，当对象引用+1，计数器+1，当对象引用-1，计数器-1；当对象引用计数器为零时，就可以进行回收
	  问题：
	  a. 循环引用问题(最典型问题)--->Python解决方法
	  b. 多线程场景下的竞争问题
	  应用:Python，javascript，FlashPlayer等脚本语言
	- 2. 可达性分析算法
	  定义：通过可达性分析算法判断对象是否存活
	  算法思路:
	  1. jvm定义一系列GC roots根对象集合
	  2. 从GC roots根对象集合作为起点，根据对象引用关系进行图遍历，形成一条条“引用链”
	  3. 确认不可达对象：对象如果到GC roots集合之间没有任意引用链相连(图论)
	  --->实践：流浪在外，无家可回的可怜孩子 
	  --->图的遍历不可达
	  例如下图中的 Object 6 ~ Object 10 之间虽有引用关系，但它们到 GC Roots 不可达，因此为需要被回收的对象。
	  ![image.png](../assets/image_1654938146561_0.png) 
	  应用:java，C#，go，Lisp
	- jvm定义的GC roots根集合
	  1. java方法栈
	  线程各个栈帧的本地变量表 临时变量，方法入参，方法返参引用的对象
	  2. 本地方法栈
	  本地方法栈JNI(俗称的native方法)引用的对象
	  3. 方法区
	  类的静态引用变量，常量池的常量引用
	  4. 本机直接内存
	  5. java虚拟机内部内存区域
	  基本类型对应的class对象
	  常驻的异常对象(NullPointException,OutOfMemoryError等）
	  系统加载类等等
	  6. 其他
	  所有被同步锁(synchronized关键字)引用的对象
	  反映虚拟机内部情况:JMXBean,JVMTI注册的回调,本地代码缓存等等
	- 判断类是否是无用的类
	  1. 该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。
	  2. 加载该类的 ClassLoader 已经被回收。
	  3. 该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。
	  虚拟机可以对这类无用类回收
	- 判断字符串常量是否“死亡"
	  运行时常量池主要回收的是废弃的常量
	  和对象判断是否死亡类似如果当前没有任何 String 对象引用该字符串常量的话，就说明常量 "abc" 就是废弃常量
- 对象"死亡"过程
	- 主要步骤
	  1. 第一次标记对象为不可达后,暂时先不回收对象
	  2. 确定是否有必要执行finalize方法
	  一个对象finalize最多只能执行一次
	  2.1 如果有必要执行对象finalized方法
	  将对象移入F-Queue队列
	  --->Finalizer守护线程(虚拟机创建，优先级极低)顺序执行队列中对象的finalized方法
	  --->执行finalized方法后 垃圾收集器对F-Queue队列中的对象进行二次标记
	  如果对象此时可达了，逃脱一次回收，下次就没机会逃脱了(最多只有一次改过自新的机会)；
	  反之如果对象仍然不可达，则执行步骤3回收对象
	  2.2 没必要执行对象finalized方法
	  3. 下次垃圾回收时再回收该对象
	- 关于finalize方法
	  1. jdk9之后标记finalize为废弃方法了,是时候忘掉这个方法了
	  废弃原因:
	  a. 无法保证各个对象的调用顺序，不确定性大
	  b. 最开始适应C，C++析构函数的产物，不适应时代发展，关闭外部资源，可以用更优雅的方式实现
	  2. 一个对象至多只能执行一次
	  3. 必要执行条件：a对象类实现了finalize方法，b对象finalized方法没有执行过
	  [是时候忘掉finalize方法了](https://mp.weixin.qq.com/s/LW-paZAMD08DP_3-XCUxmg)
- 现在收集器基本都采用分代垃圾收集算法