- 总体思路
  1. java对象内存是如何分配的？
  2. 如何判断一个对象是否该回收的“垃圾”？
  3. 什么时候进行垃圾回收？
  4. 如何进行垃圾回收？
  5. 垃圾回收效率:如何高效进行垃圾回收，同时尽可能小的影响应用程序？
  ![JVM垃圾回收.png](../assets/image_1654932154341_0.png)
  主要作用内存区域
  java堆是垃圾回收器主要作用区域
  ![堆空间结构.png](../assets/image_1654932510373_0.png)
- 对象内存分配
  TODO:cj 
  大部分情况，对象都会首先在新生代Eden区域分配
- 判断对象是否”存活"
  两种方法判断对象是否存活
	- 1. 引用计数法(Reference Counting)
	  定义:一个对象对应一个引用计数器，当对象引用+1，计数器+1，当对象引用-1，计数器-1；当对象引用计数器为零时，就可以进行回收
	  问题：
	  a. 循环引用问题(最典型问题)--->Python解决方法
	  b. 多线程场景下的竞争问题
	  应用:Python，javascript，FlashPlayer等脚本语言
	- 2. 可达性分析算法
	  定义：通过可达性分析算法判断对象是否存活
	  算法思路:
	  1. jvm定义一系列GC roots根对象集合
	  2. 从GC roots根对象集合作为起点，根据对象引用关系进行图遍历，形成一条条“引用链”
	  3. 确认不可达对象：对象如果到GC roots集合之间没有任意引用链相连(图论)
	  --->实践：流浪在外，无家可回的可怜孩子 
	  --->图的遍历不可达
	  例如下图中的 Object 6 ~ Object 10 之间虽有引用关系，但它们到 GC Roots 不可达，因此为需要被回收的对象。
	  ![image.png](../assets/image_1654938146561_0.png) 
	  应用:java，C#，go，Lisp
	- jvm定义的GC roots根集合
	  1. java方法栈
	  线程各个栈帧的本地变量表 临时变量，方法入参，方法返参引用的对象
	  2. 本地方法栈
	  本地方法栈JNI(俗称的native方法)引用的对象
	  3. 方法区
	  类的静态引用变量，常量池的常量引用
	  4. 本机直接内存
	  5. java虚拟机内部内存区域
	  基本类型对应的class对象
	  常驻的异常对象(NullPointException,OutOfMemoryError等）
	  系统加载类等等
	  6. 其他
	  所有被同步锁(synchronized关键字)引用的对象
	  反映虚拟机内部情况:JMXBean,JVMTI注册的回调,本地代码缓存等等
- 对象"死亡"过程
  主要步骤
  1. 第一次标记对象为不可达后
  2. 确定是否有必要执行finalize方法
  一个对象finalize最多只能执行一次
  2.1 如果有必要执行对象finalized方法
  将对象移入F-Queue队列
  --->Finalizer守护线程(虚拟机创建，优先级极低)顺序执行队列中对象的finalized方法
  --->执行finalized方法后 垃圾收集器对F-Queue队列中的对象进行二次标记
  如果对象此时可达了，逃脱一次回收，下次就没机会逃脱了(最多只有一次改过自新的机会)；
  反之如果对象仍然不可达，则执行步骤3回收对象
  2.2 没必要执行对象finalized方法
  3. 下次垃圾回收时回收该对象
  关于finalize方法，
  1. jdk9之后标记成废弃方法了,是时候忘掉这个方法了
  2. 一个对象至多只能执行一次
  3. 
  [是时候忘掉finalize方法了](https://mp.weixin.qq.com/s/LW-paZAMD08DP_3-XCUxmg)
- 现在收集器基本都采用分代垃圾收集算法