- 限流
  >In computer networks, rate limiting is used to control the rate of requests sent or received by a network interface controller. It can be used to prevent DoS attacks and limit web scraping。---维基百科解释
  
  简单翻译下:在计算机网络中，限流就是控制网络接口发送或接收请求的速率，它可防止DoS攻击和限制Web爬虫。
  
  限流，也称流量控制。是指系统在面临高并发，或者大流量请求的情况下，限制新的请求对系统的访问，从而保证系统的稳定性。
  
  --->类比热门旅游景区限流:一些热门的旅游景区，一般会对每日的旅游参观人数有限制的。每天只会卖出固定数目的门票，比如5000张。假设在五一、国庆假期，你去晚了，可能当天的票就已经卖完了，就无法进去游玩了。即使你进去了，排队也能排到你怀疑人生。
- 限流算法
  4大经典限流算法
	- 固定窗口限流算法
	  首先维护一个计数器，将单位时间段当做一个窗口，计数器记录这个窗口接收请求的次数。
	  1. 当次数少于限流阀值，就允许访问，并且计数器+1
	  2. 当次数大于限流阀值，就拒绝访问。
	  3. 当前的时间窗口过去之后，计数器清零。
	  
	  ![image.png](../assets/image_1655948396489_0.png)
	  描述:假设单位时间是1秒，限流阀值为3。在单位时间1秒内，每来一个请求,计数器就加1，如果计数器累加的次数超过限流阀值3，后续的请求全部拒绝。等到1s结束后，计数器清0，重新开始计数。如下图：
	  伪代码如下
	  ```
	     /**
	       * 固定窗口时间算法
	       * @return
	       */
	      boolean fixedWindowsTryAcquire() {
	          long currentTime = System.currentTimeMillis();  //获取系统当前时间
	          if (currentTime - lastRequestTime > windowUnit) {  //检查是否在时间窗口内
	              counter = 0;  // 计数器清0
	              lastRequestTime = currentTime;  //开启新的时间窗口
	          }
	          if (counter < threshold) {  // 小于阀值
	              counter++;  //计数器加1
	              return true;
	          }
	  
	          return false;
	      }
	  ```
	  算法缺点
	  这种算法有一个很明显的临界问题：假设限流阀值为5个请求，单位时间窗口是1s,如果我们在单位时间内的前0.8-1s和1-1.2s，分别并发5个请求。虽然都没有超过阀值，但是如果算0.8-1.2s,则并发数高达10，已经超过单位时间1s不超过5阀值的定义啦。
	  ![image.png](../assets/image_1655950436800_0.png)
	- 滑动窗口限流算法
	  滑动窗口限流解决固定窗口临界值的问题。它将单位时间周期分为n个小周期，分别记录每个小周期内接口的访问次数，并且根据时间滑动删除过期的小
	  周期。
	  图解:
	  ![image.png](../assets/image_1655957251001_0.png)
	  假设单位时间还是1s，总限流阀值还是为5个请求，滑动窗口算法把它划分为5个小周期，也就是滑动窗口（单位时间）被划分为5个小格子。每格表示0.2s。每过0.2s，时间窗口就会往右滑动一格。然后呢，每个小周期，都有自己独立的计数器，如果请求是0.83s到达的，0.8~1.0s对应的计数器就会加1。
	  我们来看下滑动窗口是如何解决临界问题的？
	  假设我们1s内的限流阀值还是5个请求，0.8~1.0s内（比如0.9s的时候）来了5个请求，落在黄色格子里。时间过了1.0s这个点之后，又来5个请求，落在紫色格子里。如果是固定窗口算法，是不会被限流的，但是滑动窗口的话，每过一个小周期，它会右移一个小格。过了1.0s这个点后，会右移一小格，当前的单位时间段窗口是0.2~1.2s，这个区域的请求已经超过限定的5了，已触发限流啦，实际上，紫色格子的请求都被拒绝啦。
	  TIPS: 当滑动窗口的格子周期划分的越多，那么滑动窗口的滚动就越平滑，限流的统计就会越精确。
	  问题:滑动窗口算法虽然解决了固定窗口的临界问题，但是一旦到达限流后，请求都会直接暴力被拒绝。 
	  --->漏桶算法和令牌桶算法相比较而言可以蓄一部分请求流量。
	  伪代码如下:
	  ```
	  	/**
	   * 滑动窗口限流算法
	   *
	   * @author chujun
	   * @date 2022/6/23
	   */
	  public class SlidingWindowRateLimitV2Algorithm {
	      /**
	       * 单位划分的小周期（默认单位时间是1分钟，10s一个小格子窗口，一共6个格子）
	       */
	      private int subCyclePerWindowConfig = 10;
	  
	      /**
	       * 窗口大小,单位:秒
	       */
	      private int windowSecondConfig = 60;
	  
	      /**
	       * 请求限流阈值
	       */
	      private int thresholdConfig = 100;
	  
	      /**
	       * 计数器, k-为当前窗口的开始时间值秒，value为当前窗口的计数
	       */
	      private TreeMap<Long, Integer> counters = new TreeMap<>();
	  
	      public SlidingWindowRateLimitV2Algorithm() {
	      }
	  
	      public SlidingWindowRateLimitV2Algorithm(final int subCyclePerWindowConfig,
	                                               final int windowSecondConfig,
	                                               final int thresholdConfig) {
	          this.subCyclePerWindowConfig = subCyclePerWindowConfig;
	          this.windowSecondConfig = windowSecondConfig;
	          this.thresholdConfig = thresholdConfig;
	      }
	  
	      /**
	       * 滑动窗口时间算法实现
	       */
	      boolean slidingWindowsTryAcquire() {
	          //获取当前时间在哪个小周期窗口:小周期窗口开始时间点
	          long currentSubCycleWindowStartTime = LocalDateTime.now().toEpochSecond(ZoneOffset.UTC) / subCyclePerWindowConfig * subCyclePerWindowConfig;
	          //当前窗口总请求数
	          int currentWindowNum = countCurrentWindow(currentSubCycleWindowStartTime);
	  
	          //超过阀值限流
	          if (currentWindowNum >= thresholdConfig) {
	              return false;
	          }
	  
	          //计数器+1
	          counters.merge(currentSubCycleWindowStartTime, 1, Integer::sum);
	          return true;
	      }
	  
	      /**
	       * 统计当前窗口的请求数
	       */
	      private int countCurrentWindow(long currentSubCycleWindowStartTime) {
	          //计算窗口开始位置
	          long startTime = currentSubCycleWindowStartTime - subCyclePerWindowConfig * (windowSecondConfig / subCyclePerWindowConfig - 1);
	          int count = 0;
	  
	          //遍历存储的计数器
	          Iterator<Map.Entry<Long, Integer>> iterator = counters.entrySet().iterator();
	          while (iterator.hasNext()) {
	              Map.Entry<Long, Integer> entry = iterator.next();
	              // 删除无效过期的子窗口计数器，不删除的话数据会一直堆积
	              if (entry.getKey() < startTime) {
	                  iterator.remove();
	              } else {
	                  //累加当前窗口的所有计数器之和
	                  count += entry.getValue();
	              }
	          }
	          return count;
	      }
	  
	      public int getTotalStoredSize() {
	          return counters.size();
	      }
	  }
	  ```
	- 漏桶算法
	  优点:漏桶算法面对限流，就更加的柔性，不存在直接的粗暴拒绝。
	  它的原理很简单，可以认为就是注水漏水的过程。往漏桶中以任意速率流入水，以固定的速率流出水.
	  当水超过桶的容量时，会被溢出，也就是被丢弃。因为桶容量是不变的，保证了整体的速率。
	  ![image.png](../assets/image_1656042280744_0.png)
	  说明：
	  1. 流入的水滴，可以看作是访问系统的请求，这个流入速率是不确定的。
	  2. 桶的容量一般表示系统所能处理的最大请求数。
	  3. 如果桶的容量满了，就达到限流的阀值，就会丢弃水滴（拒绝请求）
	  4. 流出的水滴，是恒定过滤的，对应服务按照固定的速率处理请求。(但这是期望上的，实际上处理速度可能不一定恒定)
	- 令牌桶算法
	- 漏桶算法和令牌桶算法的区别
- 资料
  [面试必备：4种经典限流算法讲解](https://z.itpub.net/article/detail/B049B6F216829EDD0827E97BC1AA9100)
  [漏桶算法和令牌桶算法，区别到底在哪里？](https://xie.infoq.cn/article/4a0acdd12a0f6dd4a53e0472c)