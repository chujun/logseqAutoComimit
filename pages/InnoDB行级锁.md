- 行锁触发条件是查询条件命中索引，MySQL默认使用临键锁
- 1. 记录锁（Record Lock） ：也被称为记录锁，属于单个行记录上的锁。
  记录锁触发条件:查询条件命中索引
- 2. 间隙锁（Gap Lock） ：又叫区间锁，锁定一个范围，不包括记录本身。
  当我们查询数据用范围查询而不是相等条件查询时，**查询条件命中索引，并且没有查询到符合条件的记录**，此时就会将查询条件中的范围数据进行锁定(即使是范围库中不存在的数据也会被锁定)
  间隙锁触发条件:查询条件命中索引，并且没有查询到符合条件的记录
  间隙锁特征
  1. 间隙锁锁定区间范围是左开右闭区间
  2. 间隙锁只会出现在可重复读的事务隔离级别中
  间隙锁作用示例:左开右闭区间
  我们打开两个窗口，在窗口A中我们根据id做一个范围更改操作，不提交事务，然后在范围B中插入一条记录，该记录的id值位于窗口A中的条件范围内
  ![image.png](../assets/image_1655121922806_0.png)
  查看运行结果:上述代码中，所锁定的区间就是 (1,3]这个区间,不包含1，但是包含3，并且不包含4，也就是说间隙锁这里是左开右闭区间
  间隙锁特征实验:只会出现在可重复读的事务隔离级别中
  首先将mysql数据库隔离级别修改为不可重复读
  ```
  //设置事务隔离级别为不可重复读
  set session transaction isolation level read committed;
  //查看当前事务级别
  SELECT @@tx_isolation
  ```
  打开两个窗口，在窗口A中我们根据id做一个范围更改操作，不提交事务，然后在范围B中插入一条记录，该记录的id值位于窗口A中的条件范围内
  ![image.png](../assets/image_1655122555564_0.png){:height 214, :width 698}
  运行结果分析:修改了数据库隔离级别后，再次测试间隙锁，发现间隙锁没有生效。我们可以通过rollback回滚事务。
- 3. 临键锁（Next-key Lock） ：Record Lock+Gap Lock，锁定一个范围，包含记录本身。记录锁只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁。
  临键锁触发条件:查询条件命中索引,同时有匹配到数据库记录
  临键锁是由记录锁和间隙锁共同实现的
  特征:
  临键锁锁定区间范围也是左开右闭区间，和间隙锁一样
  临键锁锁定是当前记录的区间和下一个记录的区间.
- 临键锁实验
  ![image.png](../assets/image_1655123805146_0.png)
  ![image.png](../assets/image_1655123812376_0.png)
  从上图我们可以看到，数据库中只有三条数据1、5、7，当修改范围为1~8时，则锁定的区间为(1,+∞)，锁定区间不单是查询范围，并且还锁定了当前范围的下一个范围区间(假如还有数据10，那么下一个范围区间就变成(8,10],合起来锁定区间就是(1,10])，此时，查询的区间8，在数据库中是一个不存在的记录值，并且，如果此时的查询条件是小于或等于8，也是一样的锁定8到后面的区间。
  如果查询的结尾是一个存在的值，此时又会怎样呢？
  现在数据库有三条数据id分别是1、5、7，我们查询条件改为大于1小于7再看看。
  ![image.png](../assets/image_1655123915562_0.png)
  此时，我们可以看到，由于7在数据库中是已知的记录，所以此时的锁定后，只锁定了(1,7]，7之后的数据都没有被锁定。我们还是可以正常插入id为8的数据及其后面的数据。
  结论:临键锁锁定区间和查询范围后匹配值很重要，如果后匹配值存在，则只锁定查询区间，否则锁定查询区间和后匹配值与它的下一个值的区间。
  问题：为什么临键锁后匹配会这样呢
  innodb索引是基于B+树实现的,
- 临键锁实验
  [InnoDB的next-key lock 为什么是左开右闭的？](https://www.zhihu.com/question/334081090/answer/1882156445)
	- 系统准备：mysql5.8
	- 脚本准备:初始化数据库和表，并插入实验数据
	  ```sql
	  # 建库
	  CREATE DATABASE IF NOT EXISTS lock_test DEFAULT CHARSET utf8mb4;
	  use lock_test;
	  drop table if exists test_gap;
	  # 建表
	  CREATE TABLE IF NOT EXISTS `test_gap`(
	  	`id` int(11) NOT NULL AUTO_INCREMENT, 
	  	`age` int(11) DEFAULT NULL, 
	  	`name` varchar(10) DEFAULT NULL, 
	  	PRIMARY KEY (`id`), 
	  	KEY `ix age` (`age`) 
	  )ENGINE=InnoDB AUTO_INCREMENT=97 DEFAULT CHARSET=utf8mb4;
	  # 插入数据
	  insert into test_gap(id,age)values
	  (10,10),(20,20),(30,30),(70,30),(80,31),(40,50);
	  # 关闭自动提交事务功能
	  ```
	- 查询数据
	  
	  ```
	  select * from test_gap order by age;
	  +----+-----+--------+
	  | id | age | name   |
	  +----+-----+--------+
	  | 10 | 10  | <null> |
	  | 20 | 20  | <null> |
	  | 30 | 30  | <null> |
	  | 70 | 30  | <null> |
	  | 80 | 31  | <null> |
	  | 40 | 50  | <null> |
	  +----+-----+--------+
	  6 rows in set
	  Time: 0.010s
	  ```
	  观察表上gap锁的区间如下：
	  (-无穷,10] . (10,20] . (20,30] . (30,31] . (31,50] . (50,无穷]
	-
	- 运行实验
	  开启两个session窗口
	  第一个窗口执行如下命令：
	  ```sql
	  begin;
	  select * from  test_gap where age=31 for update;
	  ```
	  查询所有事务
	  ```
	  select * from information_schema.innodb_trx;
	  +--------+-----------+---------------------+-----------------------+------------------+------------+---------------------+---------------------------------------------+---------------------+-------------------+-------------------+------------------+-----------------------+-----------------+-------------------+-------------------------+---------------------+-------------------+------------------------+----------------------------+---------------------------+---------------------------+------------------+----------------------------+---------------------+
	  | trx_id | trx_state | trx_started         | trx_requested_lock_id | trx_wait_started | trx_weight | trx_mysql_thread_id | trx_query                                   | trx_operation_state | trx_tables_in_use | trx_tables_locked | trx_lock_structs | trx_lock_memory_bytes | trx_rows_locked | trx_rows_modified | trx_concurrency_tickets | trx_isolation_level | trx_unique_checks | trx_foreign_key_checks | trx_last_foreign_key_error | trx_adaptive_hash_latched | trx_adaptive_hash_timeout | trx_is_read_only | trx_autocommit_non_locking | trx_schedule_weight |
	  +--------+-----------+---------------------+-----------------------+------------------+------------+---------------------+---------------------------------------------+---------------------+-------------------+-------------------+------------------+-----------------------+-----------------+-------------------+-------------------------+---------------------+-------------------+------------------------+----------------------------+---------------------------+---------------------------+------------------+----------------------------+---------------------+
	  | 66124  | RUNNING   | 2022-06-13 22:02:50 | <null>                | <null>           | 4          | 13                  | select * from information_schema.innodb_trx | <null>              | 0                 | 1                 | 4                | 1136                  | 3               | 0                 | 0                       | REPEATABLE READ     | 1                 | 1                      | <null>                     | 0                         | 0                         | 0                | 0                          | <null>              |
	  +--------+-----------+---------------------+-----------------------+------------------+------------+---------------------+---------------------------------------------+---------------------+-------------------+-------------------+------------------+-----------------------+-----------------+-------------------+-------------------------+---------------------+-------------------+------------------------+----------------------------+---------------------------+---------------------------+------------------+----------------------------+---------------------+
	  ```
	  查询事务的锁信息
	  ```
	  select * from performance_schema.data_locks;
	  +--------+-----------------------------------------+-----------------------+-----------+----------+---------------+-------------+----------------+-------------------+------------+-----------------------+-----------+---------------+-------------+-----------+
	  | ENGINE | ENGINE_LOCK_ID                          | ENGINE_TRANSACTION_ID | THREAD_ID | EVENT_ID | OBJECT_SCHEMA | OBJECT_NAME | PARTITION_NAME | SUBPARTITION_NAME | INDEX_NAME | OBJECT_INSTANCE_BEGIN | LOCK_TYPE | LOCK_MODE     | LOCK_STATUS | LOCK_DATA |
	  +--------+-----------------------------------------+-----------------------+-----------+----------+---------------+-------------+----------------+-------------------+------------+-----------------------+-----------+---------------+-------------+-----------+
	  | INNODB | 140233293675848:1606:140233557539392    | 66124                 | 54        | 66       | lock_test     | test_gap    | <null>         | <null>            | <null>     | 140233557539392       | TABLE     | IX            | GRANTED     | <null>    |
	  | INNODB | 140233293675848:349:5:6:140233568248352 | 66124                 | 54        | 66       | lock_test     | test_gap    | <null>         | <null>            | ix age     | 140233568248352       | RECORD    | X             | GRANTED     | 31, 80    |
	  | INNODB | 140233293675848:349:4:6:140233568248696 | 66124                 | 54        | 66       | lock_test     | test_gap    | <null>         | <null>            | PRIMARY    | 140233568248696       | RECORD    | X,REC_NOT_GAP | GRANTED     | 80        |
	  | INNODB | 140233293675848:349:5:7:140233568249040 | 66124                 | 54        | 66       | lock_test     | test_gap    | <null>         | <null>            | ix age     | 140233568249040       | RECORD    | X,GAP         | GRANTED     | 50, 40    |
	  +--------+-----------------------------------------+-----------------------+-----------+----------+---------------+-------------+----------------+-------------------+------------+-----------------------+-----------+---------------+-------------+-----------+
	  ```
	  观察到该事务下有下面几种锁
	  1.
	- 实验结果
	- 分析
	- 结论
	-