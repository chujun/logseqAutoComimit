- 数据库类型
  关系型数据库:一种建立在关系模型的基础上的数据库
  关系模型表明了数据库中所存储的数据之间的联系（一对一、一对多、多对多）
  大部分关系型数据库都使用 SQL 来操作数据库中的数据。并且，大部分关系型数据库都支持事务的四大特性(ACID)。
  [[MySQL]]
  Oracle
  SQL-Server
  PostgreSQL
  SQLite
- 基本概念
	- 元组 ： 元组（tuple）是关系数据库中的基本概念，关系是一张表，表中的每行（即数据库中的每条记录）就是一个元组，每列就是一个属性。 在二维表里，元组也称为行。
	- 码 ：码就是能唯一标识实体的属性，对应表中的列。
	- 候选码 ： 若关系中的某一属性或属性组的值能唯一的标识一个元组，而其任何、子集都不能再标识，则称该属性组为候选码。例如：在学生实体中，“学号”是能唯一的区分学生实体的，同时又假设“姓名”、“班级”的属性组合足以区分学生实体，那么{学号}和{姓名，班级}都是候选码。
	- 主码 : 主码也叫主键。主码是从候选码中选出来的。 一个实体集中只能有一个主码，但可以有多个候选码。
	- 外码 : 外码也叫外键。如果一个关系中的一个属性是另外一个关系中的主码则这个属性为外码。
	- 主属性 ： 候选码中出现过的属性称为主属性。比如关系 工人（工号，身份证号，姓名，性别，部门）. 显然工号和身份证号都能够唯一标示这个关系，所以都是候选码。工号、身份证号这两个属性就是主属性。如果主码是一个属性组，那么属性组中的属性都是主属性。
	- 非主属性： 不包含在任何一个候选码中的属性称为非主属性。比如在关系——学生（学号，姓名，年龄，性别，班级）中，主码是“学号”，那么其他的“姓名”、“年龄”、“性别”、“班级”就都可以称为非主属性。
- 函数依赖
	- 函数依赖（functional dependency） ：若在一张表中，在属性（或属性组）X 的值确定的情况下，必定能确定属性 Y 的值，那么就可以说 Y 函数依赖于 X，写作 X → Y。
	- 部分函数依赖（partial functional dependency） ：如果 X→Y，并且存在 X 的一个真子集 X0，使得 X0→Y，则称 Y 对 X 部分函数依赖。比如学生基本信息表 R 中（学号，身份证号，姓名）当然学号属性取值是唯一的，在 R 关系中，（学号，身份证号）->（姓名），（学号）->（姓名），（身份证号）->（姓名）；所以姓名部分函数依赖与（学号，身份证号）；
	- 完全函数依赖(Full functional dependency) ：在一个关系中，若某个非主属性数据项依赖于全部关键字称之为完全函数依赖。比如学生基本信息表 R（学号，班级，姓名）假设不同的班级学号有相同的，班级内学号不能相同，在 R 关系中，（学号，班级）->（姓名），但是（学号）->(姓名)不成立，（班级）->(姓名)不成立，所以姓名完全函数依赖于（学号，班级）；
	- 传递函数依赖 ： 在关系模式 R(U)中，设 X，Y，Z 是 U 的不同的属性子集，如果 X 确定 Y、Y 确定 Z，且有 X 不包含 Y，Y 不确定 X，（X∪Y）∩Z=空集合，则称 Z 传递函数依赖(transitive functional dependency) 于 X。传递函数依赖会导致数据冗余和异常。传递函数依赖的 Y 和 Z 子集往往同属于某一个事物，因此可将其合并放到一个表中。比如在关系 R(学号 , 姓名, 系名，系主任)中，学号 → 系名，系名 → 系主任，所以存在非主属性系主任对于学号的传递函数依赖。。
- 数据库范式
	- 1NF(第一范式)
	  定义:属性（对应于表中的字段）不能再被分割，也就是这个字段只能是一个值，不能再分为多个其他的字段了。
	  关系数据库:1NF 是所有关系型数据库的最基本要求 ，也就是说关系型数据库中创建的表一定满足第一范式。
	- 2NF(第二范式)
	  定义:2NF：1NF 的基础之上，消除了非主属性对于码的部分函数依赖。
	  第二范式在第一范式的基础上增加了一个列，这个列称为主键，非主属性都依赖于主键。
	  ![展示了第一范式到第二范式的过渡.png](../assets/image_1655103288740_0.png)
	- 3NF(第三范式)
	  定义:3NF：3NF 在 2NF 的基础之上，消除了非主属性对于码的传递函数依赖 。
	  符合 3NF 要求的数据库设计，基本上解决了数据冗余过大，插入异常，修改异常，删除异常的问题。
	  举例:在关系 R(学号 , 姓名, 系名，系主任)中，学号 → 系名，系名 → 系主任，所以存在非主属性系主任对于学号的传递函数依赖，所以该表的设计，不符合 3NF 的要求。
-
-
- E-R 图 也称实体-联系图(Entity Relationship Diagram)
  提供了表示实体类型、属性和联系的方法，用来描述现实世界的概念模型
  ![E-R图.png](../assets/image_1655101584794_0.png)
  ![数据库的关系模型.png](../assets/image_1655101636246_0.png)
- 数据库事务
	- 事务是逻辑上的一组操作，要么都执行，要么都不执行。
	  事务最经典也经常被拿出来说例子就是转账了。假如小明要给小红转账 1000 元，这个转账会涉及到两个关键操作，这两个操作必须都成功或者都失败。
	  将小明的余额减少 1000 元
	  将小红的余额增加 1000 元。
	  事务会把这两个操作就可以看成逻辑上的一个整体，这个整体包含的操作要么都成功，要么都要失败。这样就不会出现小明余额减少而小红的余额却并没有增加的情况。
	- 事务4大特性(ACID)
	  1. 原子性（Atomicity） ： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；
	  2. 一致性（Consistency）： 执行事务前后，数据保持一致性，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；
	  3. 隔离性（Isolation）： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；
	  4. 持久性（Durabilily）： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。
	  关系说明：只有保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。也就是说 A、I、D 是手段，C 是目的！
	- 事务引发的问题
	  1. 脏读（Dirty read）
	  定义：一个事务读取了未提交事务的数据
	  2. 不可重复读（Unrepeatable read）
	  定义:在一个事务内多次读同一数据，前后两次数据是不一样的。
	  在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。
	  3. 幻读（Phantom read）
	  定义:它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入/删除了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了/少了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。
	  
	  并发情况下还存在丢失修改问题，一般应用程序使用分布式锁避免并发修改
	- SQL 标准定义了四个隔离级别
	  |隔离级别	|脏读	|不可重复读	|幻读|
	  |---|---|---|---|
	  |
	  |
	- 数据库事务
	  保证多个对数据库的操作（也就是 SQL 语句构成一个逻辑上的整体）。这些数据库操作保证要么全部执行成功,要么全部不执行.
	  ```
	  # 开启一个事务
	  START TRANSACTION;
	  # 多条 SQL 语句
	  SQL1,SQL2...
	  ## 提交事务
	  COMMIT;
	  ```
	- 分布式事务
-
-
- 存储过程
  使用存储过程比单纯 SQL 语句执行要快，因为存储过程是预编译过的。
  
  存储过程在互联网公司应用不多，因为存储过程难以调试和扩展，而且没有移植性，还会消耗数据库资源。
- DDL和DML
	- DDL(Data Definition Language)
	  数据定义语言:数据定义语言的缩写，简单来说，就是对数据库内部的对象进行创建、删除、修改的操作语言。
	- DML(Data Manipulation Language)
	  数据操作语言:指对数据库中表记录的操作，主要包括表记录的插入（insert）、更新（update）、删除（delete）和查询（select）
	- 两者区别
	  1. DML 只是对表内部数据的操作，而不涉及到表的定义、结构的修改，更不会涉及到其他对象。
	  2. DDL 语句更多的被数据库管理员（DBA）所使用，一般的开发人员很少使用。DML是开发人员日常使用最频繁的操作。
- SQL truncate,delete与drop区别
  1. 含义区别
  drop(丢弃数据): drop table 表名 ，直接将表结构都删除掉，删除表数据，在删除表的时候使用。
  truncate (清空数据) : truncate table 表名 ，表结构还在，只删除表中的数据，再插入数据的时候自增长 id 又从 1 开始，在清空表中数据的时候使用。
  delete（删除数据） : 表结构还在，delete from 表名 where 列名=值，删除某一行的数据，如果不加 where 子句则删除表所有数据。
  2. DDL和DML的区别
  truncate 和 drop 属于 DDL(数据定义语言)语句，操作立即生效，原数据不放到 rollback segment 中，不能回滚，操作不触发 trigger。
  delete 语句是 DML (数据库操作语言)语句，这个操作会放到 rollback segement 中，事务提交之后才生效。
  3. 执行速度差异
  一般来说：drop > truncate > delete
  delete命令执行的时候会产生数据库的binlog日志，而日志记录是需要消耗时间的，但是也有个好处方便数据回滚恢复。
  truncate命令执行的时候不会产生数据库日志，因此比delete要快。除此之外，还会把表的自增值重置和索引恢复到初始大小等。
  drop命令会把表占用的空间全部释放掉。
- 数据库设计通常步骤
  1. 需求分析 : 分析用户的需求，包括数据、功能和性能需求。
  2. 概念结构设计 : 主要采用 E-R 模型进行设计，包括画 E-R 图。
  3. 逻辑结构设计 : 通过将 E-R 图转换成表，实现从 E-R 模型到关系模型的转换。
  4. 物理结构设计 : 主要是为所设计的数据库选择合适的存储结构和存取路径。
  5. 数据库实施 : 包括编程、测试和试运行
  6. 数据库的运行和维护 : 系统的运行与数据库的日常维护。
- 推荐书籍
  《Designing Data-Intensive Application（数据密集型应用系统设计）》5星推荐
  [中文翻译版本已经在 Github 开源](https://github.com/Vonng/ddia) 。