- 数据结构：布隆过滤器（Bloom Filter）是一个叫做 Bloom 的老哥于 1970 年提出的。我们可以把它看作由二进制向量（或者说位数组）和一系列随机映射函数（哈希函数）两部分组成的数据结构。
  作用:通过它我们可以非常方便地判断一个给定数据是否存在于海量数据中。
  布隆过滤器描述：把所有可能存在的请求的值都存放在布隆过滤器中，当用户请求过来，先判断用户发来的请求的值是否存在于布隆过滤器中。不存在的话，直接返回请求参数错误信息给客户端，存在的话才会走下面的流程。
- 布隆过滤器原理: 比特位组数组+N组哈希函数
  一个元素加入布隆过滤器中的过程分析：
  1. 使用布隆过滤器中的哈希函数对元素值进行计算，得到哈希值（有几个哈希函数得到几个哈希值）。
  2. 根据得到的哈希值，在位数组中把对应下标的值置为 1。
  ![image.png](../assets/image_1655881221394_0.png) 
  判断一个元素是否存在于布隆过滤器过程分析：
  1. 对给定元素进行哈希计算；
  2. 得到值之后判断位数组中的每个元素是否都为 1，如果值都为 1，那么说明这个值大概率在布隆过滤器中，如果存在一个值不为 1，说明该元素一定不在布隆过滤器中。
  一定会出现这样一种情况：不同的字符串可能哈希出来的位置相同。
- 解决方案:可以适当增加位数组大小或者调整我们的哈希函数来降低概率
  缺点：
  1. 存在一定程度上的误判,比如不存在的key通过校验，但是绝对不允许存在的key不通过校验。
  2. 删除比较困难,如果数据会动态删除则不适合用布隆过滤器处理
  内存占用量计算：1亿条数据，占用内存 100000000/8/1024/1024=11M
- 布隆过滤器使用场景
  1. 判断给定数据是否存在：
  比如判断一个数字是否存在于包含大量数字的数字集中（数字集很大，5 亿以上！）、
   防止缓存穿透（判断请求的数据是否有效避免直接绕过缓存请求数据库）等等、
  邮箱的垃圾邮件过滤、
  黑名单功能等等。
  2. 去重：比如爬给定网址的时候对已经爬取过的 URL 去重。
- 单机和分布式
	- 单机版本:利用 Google 开源的 Guava 中自带的布隆过滤器
	  我们创建了一个最多存放 最多 1500 个整数的布隆过滤器，并且我们可以容忍误判的概率为百分之（0.01）
	  ```
	  / 创建布隆过滤器对象
	  BloomFilter<Integer> filter = BloomFilter.create(
	      Funnels.integerFunnel(),
	      1500,
	      0.01);
	  // 判断指定元素是否存在
	  System.out.println(filter.mightContain(1));
	  System.out.println(filter.mightContain(2));
	  // 将元素添加进布隆过滤器
	  filter.put(1);
	  filter.put(2);
	  System.out.println(filter.mightContain(1));
	  System.out.println(filter.mightContain(2));
	  ```
	  在我们的示例中，当 mightContain() 方法返回 true 时，我们可以 99％确定该元素在过滤器中，当过滤器返回 false 时，我们可以 100％确定该元素不存在于过滤器中。
	  缺点:一个重大的缺陷就是只能单机使用（另外，容量扩展也不容易），而现在互联网一般都是分布式的场景.
	- Redis 中的布隆过滤器
	  官网推荐了一个 RedisBloom 作为 Redis 布隆过滤器的 Module，地址：https://github.com/RedisBloom/RedisBloom
- 资料
  [布隆过滤器](https://javaguide.cn/cs-basics/data-structure/bloom-filter.html#%E4%BB%80%E4%B9%88%E6%98%AF%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8)