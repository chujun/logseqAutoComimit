- I/O（Input/Outpu） 即输入／输出
- 从计算机结构体系角度认识IO
  根据冯.诺依曼结构，计算机结构分为 5 大部分：运算器、控制器、存储器、输入设备、输出设备.
  ![image.png](../assets/image_1653804633725_0.png) 
  从计算机结构的视角来看的话， I/O 描述了计算机系统与外部设备之间通信的过程.
- 从应用程序角度认识IO
	- 用户空间和内核空间
	  操作系统:为了保证操作系统的稳定性和安全性，一个进程的地址空间划分为 用户空间（User space） 和 内核空间（Kernel space ）.
	  应用程序都是运行在用户空间。应用程序不能直接访问内核空间。
	  只有内核空间才能进行系统态级别的资源有关的操作，比如文件管理、进程通信、内存管理等等。
	- 应用程序想进行IO操作(例如磁盘IO，网络IO等),必须调用操作系统的*系统调用*api访问内核空间。
	  从应用程序的视角来看的话，我们的应用程序对操作系统的内核发起 IO 调用（系统调用），操作系统负责的内核执行具体的 IO 操作。我们的应用程序实际上只是发起了 IO 操作的调用而已，具体 IO 的执行是由操作系统的内核来完成的。
	- 应用程序发起 I/O 调用后，会经历两个步骤：(这个认知很重要)
	  1. 等待数据准备好（Waiting for the data to be ready）
	  2. 从内核向进程复制数据（Copying the data from the kernel to the process）
- 准备知识
  都是计算机系统的基础知识(TODO:cj 需要补课)
	- 1. 虚拟内存
	  虚拟内存为每个进程提供一个一致私有的地址空间，每个进程拥有一片连续完整的内存空间，让进程有种在独享主存的美好错觉。
	  实际上，虚拟内存通常被分隔成多个物理内存碎片，还有部分暂存在外部磁盘存储器，在需要时进行数据交换，加载到物理内存中来
	  当用户进程发出内存申请请求，系统会为进程分配虚拟地址，并创建内存映射放入页表中，如果对应的数据不在物理内存上就会发生缺页异常，需要把进程需要的数据从磁盘上拷贝到物理内存中。
	  ![image.png](../assets/image_1653807210194_0.png)
	- 2. 用户空间和内核空间
	  操作系统的核心是内核，独立于普通应用程序，可访问受保护的内存空间，也可访问底层硬件设备。 
	  应用程序只能访问用户空间,不能直接访问内核空间.需要通过操作系统内核的**系统调用**才能访问内核空间。而这个**系统调用**比较高.
	  ![image.png](../assets/image_1653807823131_0.png)
	- 3. 内核态和用户态
	  CPU内核态当进程经过系统调用而陷入内核代码中执行时，称进程处于内核运行态
	  用户态:运行在用户空间执行用户自己的代码时，处于用户态
	  
	  用户态转内核态的上下文切换
	  当用户进程想要执行 IO 操作时，由于没有执行这些操作的权限，只能发起系统调用请求操作系统帮忙完成。而系统调用会产生中断陷入到内核，也就是进行了一次上下文切换操作。
	  进程切换时，需保存、装载各种状态数据等资源， 代价就比较高。
	- 4.进程上下文切换
	  到了内核，为了控制进程执行，内核必须有能力挂起正在 CPU 上运行的进程，并恢复以前挂起的某个进程的执行。这种行为被称为进程切换。
- Linux IO读写方式
- I/O设备与CPU的通信方式
  1. I/O中断
  在DMA技术出现前，应用程序与磁盘间的 I/O 操作都通过 CPU 中断完成。
  ![image.png](../assets/image_1653811901564_0.png) 
  步骤:外部存储设备采用中断方式主动通知 CPU，CPU 负责拷贝数据到内核缓冲区，再拷贝到用户缓冲区
  代价:每次都会有上下文切换开销和CPU拷贝开销.
  2. DMA技术（直接存储器存储Direct Memory Access)
  定义:一种允许外围设备直接访问系统主存的机制
  ![image.png](../assets/image_1653812462739_0.png)
  
  步骤:CPU 通知 DMA 控制器拷贝外部存储设备数据到内核缓冲区，完成后再通知 CPU 拷贝到用户缓冲区。
  
  和I/O中断比较: I/O 中断方式相比，改由内存来执行外部存储器数据的 I/O 操作，减轻了CPU负担，且 CPU 读取内存比读取外部存储设备速度要快。省了一次CPU拷贝的开销。
  
  目前大多数硬件设备都支持DAM技术，例如包括磁盘、网卡、声卡等。
- [[文件传输的零拷贝技术]]
- 大文件IO选择
- 五种常见的I/O模型
  阻塞非阻塞:应用程序发起系统调用后，是否需要阻塞住等待内核告知数据准备就绪。是的话就是阻塞，否的话就是非阻塞.(应用程序轮训方式也是非阻塞的,)
  同步异步:IO第二阶段从内核复制数据到用户空间这个过程期间用户进程是否需要阻塞等待。是的话就是同步，否的话就是异步。
  简单口诀判断方法：阻塞非阻塞看IO第一个阶段，同步异步看IO第二个阶段
  UNIX 系统下， IO 模型一共有 5 种：
	- 同步阻塞 I/O
	  等待数据、拷贝数据两个阶段都是处于阻塞状态的。 这就是同步阻塞。
	  ![image.png](../assets/image_1653808652432_0.png)
	-
	- 同步非阻塞 I/O
	  在I/O执行的第一个阶段（等待数据）不会阻塞线程，但在第二阶段（复制数据）会阻塞。
	  第一个阶段其实就是轮询(polling)，以查询某个操作是否就绪。
	  当数据没准备好则返回 EWOULDBLOCK。
	  这就是同步非阻塞(轮训期间可能的话用户程序也是可以干点别的)。
	  ![image.png](../assets/image_1653810205054_0.png)
	  缺点：比较耗费CPU资源
	- I/O多路复用
	  定义:也称事件驱动IO，在单个线程里同时监控多个套接字，通过 select /poll轮询/epoll查看所负责的所有 socket，当某个 socket 有数据到达了，就通知用户进程。
	  select/poll/epoll三种函数实现
	  select:可以同时等待多个IO数据准备就绪,进程阻塞,只要有任意一个就绪，就返回
	  poll:可以同时轮训多个IO数据准备是否就绪，只要有任意一个就绪，就返回
	  epollo:TODO:cj
	  ![image.png](../assets/image_1653824421764_0.png)
	  
	  
	  待确定？如果用的是poll方式，是不是就是同步非阻塞的。
	  优势：可以同时等待多个描述符就绪。
	  多路复用三种实现
	  1. select 
	  select函数工作过程:多个进程的 IO 可以注册到同一个管道上，关键是select函数，多个进程的 IO 可以注册到同一个select上，当用户进程调用该select，select会监听所有注册好的 IO，如果所有被监听的 IO 需要的数据都没有准备好时，调用进程会阻塞，等待有套接字变为可读。当任意一个 IO 需要的数据准备好后，即当有套接字可读以后，select调用就会返回，然后进程再通过recvfrom来把对应的数据拷贝到用户进程缓冲区。
	  IO 复用的特点是进行了两次系统调用，进程先是阻塞在 select 上，再阻塞在读操作的第二个阶段上。这是同步阻塞的。
	  2. poll
	  3. epoll
	- 信号驱动式I/O(signal-driven I/O)
	  定义:相比于同步非阻塞IO，我们可以让内核在数据准备好时发SIGIO信号通知用户进程，这种模型称为信号驱动式I/O.
	  主要过程:首先要开启 socket 的信号驱动式 IO 功能，应用进程通过 sigaction 系统调用注册 SIGIO 信号处理函数，该系统调用会立即返回。当数据准备好时，内核会为该进程产生一个 SIGIO 信号通知，之后再把数据拷贝到用户空间中。
	  ![image.png](../assets/image_1653811191681_0.png)
	  
	  在I/O执行的第一个阶段（等待数据）不会阻塞线程，但在第二阶段（复制数据）会阻塞。这是同步非阻塞。
	  说明：这种IO模型java当中并没有使用到。
	- 异步 I/O
-
- java IO模型
  BIO(Blocking IO)同步阻塞IO模型,最传统的模型。
  在客户端连接数量不高的情况下，是没问题的。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。我们需要一种更高效的 I/O 处理模型来应对更高的并发量。
  NIO(Non Blocking IO) jdk4引入
  AIO(Aysnc IO)jdk7引入
- 多线程中使用的IO模型
-
- 资料
  [如何完成一次 IO](https://llc687.top/126.html)
  [原来 8 张图，就可以搞懂「零拷贝」了](https://www.cnblogs.com/xiaolincoding/p/13719610.html)
- 书籍
  《UNIX 网络编程 卷1:套接字联网 API 》6.2 节 IO 模型