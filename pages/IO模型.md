- I/O（Input/Outpu） 即输入／输出
- 从计算机结构体系角度认识IO
  根据冯.诺依曼结构，计算机结构分为 5 大部分：运算器、控制器、存储器、输入设备、输出设备.
  ![image.png](../assets/image_1653804633725_0.png) 
  从计算机结构的视角来看的话， I/O 描述了计算机系统与外部设备之间通信的过程.
- 从应用程序角度认识IO
	- 用户空间和内核空间
	  操作系统:为了保证操作系统的稳定性和安全性，一个进程的地址空间划分为 用户空间（User space） 和 内核空间（Kernel space ）.
	  应用程序都是运行在用户空间。应用程序不能直接访问内核空间。
	  只有内核空间才能进行系统态级别的资源有关的操作，比如文件管理、进程通信、内存管理等等。
	- 应用程序想进行IO操作(例如磁盘IO，网络IO等),必须调用操作系统的*系统调用*api访问内核空间。
	  从应用程序的视角来看的话，我们的应用程序对操作系统的内核发起 IO 调用（系统调用），操作系统负责的内核执行具体的 IO 操作。我们的应用程序实际上只是发起了 IO 操作的调用而已，具体 IO 的执行是由操作系统的内核来完成的。
	- 应用程序发起 I/O 调用后，会经历两个步骤：
	  1. 等待数据准备好（Waiting for the data to be ready）
	  2. 从内核向进程复制数据（Copying the data from the kernel to the process）
- 准备知识
  都是计算机系统的基础知识(TODO:cj 需要补课)
	- 1. 虚拟内存
	  虚拟内存为每个进程提供一个一致私有的地址空间，每个进程拥有一片连续完整的内存空间，让进程有种在独享主存的美好错觉。
	  实际上，虚拟内存通常被分隔成多个物理内存碎片，还有部分暂存在外部磁盘存储器，在需要时进行数据交换，加载到物理内存中来
	  当用户进程发出内存申请请求，系统会为进程分配虚拟地址，并创建内存映射放入页表中，如果对应的数据不在物理内存上就会发生缺页异常，需要把进程需要的数据从磁盘上拷贝到物理内存中。
	  ![image.png](../assets/image_1653807210194_0.png)
	- 2. 用户空间和内核空间
	  操作系统的核心是内核，独立于普通应用程序，可访问受保护的内存空间，也可访问底层硬件设备。 
	  应用程序只能访问用户空间,不能直接访问内核空间.需要通过操作系统内核的**系统调用**才能访问内核空间。而这个**系统调用**比较高.
	  ![image.png](../assets/image_1653807823131_0.png)
	- 3. 内核态和用户态
	  CPU内核态当进程经过系统调用而陷入内核代码中执行时，称进程处于内核运行态
	  用户态:运行在用户空间执行用户自己的代码时，处于用户态
	  
	  用户态转内核态的上下文切换
	  当用户进程想要执行 IO 操作时，由于没有执行这些操作的权限，只能发起系统调用请求操作系统帮忙完成。而系统调用会产生中断陷入到内核，也就是进行了一次上下文切换操作。
	  进程切换时，需保存、装载各种状态数据等资源， 代价就比较高。
	- 4.进程上下文切换
	  到了内核，为了控制进程执行，内核必须有能力挂起正在 CPU 上运行的进程，并恢复以前挂起的某个进程的执行。这种行为被称为进程切换。
- Linux IO读写方式
- IO读写方式的具体实现思路
- 五种常见的I/O模型
  阻塞非阻塞
  同步异步
  UNIX 系统下， IO 模型一共有 5 种：
	- 同步阻塞 I/O
	  等待数据、拷贝数据两个阶段都是处于阻塞状态的。 这就是同步阻塞。
	  ![image.png](../assets/image_1653808652432_0.png)
	-
	- 同步非阻塞 I/O
	  在I/O执行的第一个阶段（等待数据）不会阻塞线程，但在第二阶段（复制数据）会阻塞。
	  第一个阶段其实就是轮询(polling)，以查询某个操作是否就绪。
	  当数据没准备好则返回 EWOULDBLOCK。
	  这就是同步非阻塞。
	  ![image.png](../assets/image_1653810205054_0.png)
	  缺点：比较耗费CPU资源
	- I/O 多路复用
	  select/poll/epoll函数
	- 信号驱动 I/O
	- 异步 I/O
-
- java IO模型
  BIO(Blocking IO)同步阻塞IO模型,最传统的模型。
  在客户端连接数量不高的情况下，是没问题的。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。我们需要一种更高效的 I/O 处理模型来应对更高的并发量。
  NIO(Non Blocking IO) jdk4引入
  AIO(Aysnc IO)jdk7引入
- 零拷贝技术
- 资料
  [如何完成一次 IO](https://llc687.top/126.html)
  [IO模型详解](https://javaguide.cn/java/basis/io.html#%E4%BD%95%E4%B8%BA-i-o)
- 书籍
  《UNIX 网络编程 卷1:套接字联网 API 》6.2 节 IO 模型