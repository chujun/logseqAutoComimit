- 类的生命周期
  虚拟机的类加载机制是在运行期动态加载完成的。-->Applet,JSP,OSGI等技术
  类的生命周期7个阶段:加载,验证,准备,解析,初始化,使用,卸载。
  ![类的生命周期.png](../assets/类的生命周期_1653383997296_0.png)
	- 类初始化时机
	  目前的java虚拟机规范 ((628ca746-598e-4db5-b964-7c4a80b26680))有且仅有规定了6种情况进行类的初始化。类的初始化至多只有一次。(语法细节,理解即可)
	  1. 遇到new、getstatic、putstatic或invokestatic这四条字节码指令时。
	  典型java调用场景
	  使用new关键字实例化对象的时候。
	  读取或设置一个类型的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）的时候。-->(编译器优化,这时其实类的静态字段其实就是常量池中的一个普通常量了，可以通过代码简单验证)
	  调用一个类型的静态方法的时候
	  2. 使用java.lang.reflect包的方法对类型进行反射调用的时候
	  3. 当初始化类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。
	  4. 当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类）
	  5. 当使用JDK 7新加入的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果为REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial四种类型的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化.(如何验证，MethodHandle 和 VarHandle 可以看作是轻量级的反射调用机制)
	  6. 当一个接口中定义了JDK 8新加入的默认方法（被default关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化
	  也称主动引用，其他情况都不会进行类的初始化。
	  除此之外的引用类型方式称为被动引用.不会触发类初始化。常见场景有
	  1. Class
	  2. ClassLoader加载类
	  3. Class.forName
	  4. 通过数组定义来引用类, SuperClass[] arr=new SuperClass[10];
	  5. 直接引用类的常量(static final修饰) Constant.GOOGLE
- 类加载过程
  5个过程详情分析
	- 加载(Loading)
		- 主要工作任务
		  1）通过一个类的全限定名来获取定义此类的二进制字节流。
		  2）将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
		  3）在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口
		-
	- 验证
	- 准备
	- 解析
	- 初始化
	-
- 类加载器
- 双亲委派模型
  ![classloader_双亲委派模型.png](../assets/classloader_WPS图片_1653383277416_0.png)
- 资料
  书籍《深入理解java虚拟机:JVM高级特性与最佳实践》(第三版) 作者周志明