- HotSpot虚拟机中主要分为三部分
- 1. 对象头(Header)
  对象头主要有两部分,数组对象有第三部分
	- a.MarkWord
	  id:: 62a345a3-9053-4a22-a6a5-7110ec4b3ef5
	  用于存储对象自身的运行时数据，如一致性哈希码（Identity HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。
	  一致性哈希码说明:这儿指的是对象的一致性哈希码(Identity HashCode),
	  System.identityHashCode(obj)返回的值。而非对象的hashcode方法返回的值。
	  特性:这个值是能强制保证不变的，它通过在对象头中存储计算结果来保证第一次计算之后，再次调用该方法取到的哈希码值永远不会再发生改变。
	  设计目的：定义动态的数据结构，尽可能多的复用相同位数,就是为了减小对象所需的内存空间
	  按照对象的不同状态存储的数据类型也不一样。
	  32位和64位不同
	  ![32位虚拟机对象头MarkWord.png](../assets/截屏2022-06-02_下午9.11.26_1654175648260_0.png)
	  
	  问题:如何处理MarkWord比特位复用问题？
	  例如当对象进入偏向状态的时候，MarkWord大部分的空间（23个比特）都用于存储持有锁的线程ID了，这部分空间占用了原有存储对象一致性哈希码的位置，那原来对象的一致性哈希码怎么储存呢?
	  1. 当一个对象计算过一致性哈希码后，它就不能进入偏向锁状态了。 ((6298791f-12c9-4fb8-b68a-60855d19aefa)) 
	  2. 当一个对象处于偏向锁状态时，收到计算其一致性哈希码需求时，它的排向锁状态解除，并且会升级为重量级锁。
	  3. 当一个对象处于轻量级锁状态时,怎么存储对象的一致性哈希码呢?
	  指向调用栈中锁记录(Lock Record)的指针指向的是加轻量级锁时MarkWord的拷贝，所以这儿自然可以存储一致性哈希码 ((6298b2ff-7bc1-4d9f-aa5d-2f72933bc324))
	  4. 当一个对象处于重量级锁状态时，对象头指向了重量级锁的位置，代表重量级锁的ObjectMonitor类里有字段可以记录非加锁状态（标志位为“01”）下的Mark Word，其中自然可以存储原来的一致性哈希码
	- b.类型指针：对象指向它的类型元数据的指针
	  不是所有虚拟机实现都必须要包含该指针，和对象如何访问类型方式有关
	- c.记录数组长度的数据(数组对象才有的部分,4个字节int长度)
- 2 .实例数据(Instance Data)
  存储对象真正存储的有效信息
  无论是从父类继承下来的，还是在子类中定义的字段都必须记录起来。
  属于oop-klass二分模型，也就是说对象实例数据和对象类型元数据(字段定义，方法，常量池等数据)分开存储
  分配规则
  1. 先父类，再子类
  2. 相同长度大小的字段总是在一起分配，double/long（8字节）,ints(int/float)（4字节）,short/char（2字节）,byte/boolean(1个字节）,oops（Ordinary Object Pointers，OOPs）(一般8个字节)
  3. 相同长度的字段顺序按照源码定义顺序来分配
  --->总体分配顺序1.从父到子->2.从大而小->3.顺序分配->4.填充对齐(最后一步)
   
  存储顺序
- 3. 对齐填充(Padding)
  占位符的使用场景
  1. HotSpot虚拟机要求对象起始地址必须是8字节的整数倍
  对象头已经正好是8的整数倍了,如果有必要只要将实例数据处理成整数倍就好了
  2. 字段偏移规则
  该字段的位置 - 对象起始位置 = mS (m >=1) 即是S的m倍。不足的则对齐填充
  3. @Contended 伪共享处理
  128个字节用于解决内存伪共享问题，64位字节的两倍
  实验
  实际验证，实验：通过Unsafe获取实例字段和静态字段的偏移量
  @sun.misc.Contended处理伪共享问题的对齐
- jvm对象堆内存布局相关jvm参数
  FieldsAllocationStyle=0，1，2，默认为1,  0：先对象引用，再基本类型，1：先基本类型，再对象引用，jvm默认方式
  +XX:CompactFields：默认为true，是否允许子类中较窄的字段插入到父类字段间隙中
  -XX:-UseCompressedOops 普通对象指针压缩,默认没有开启
  -XX:-UseCompressedClassPointers 类指针压缩,默认没有开启,只有在UseCompressedOops开启情况下，该参数才能生效
- java对象内存布局分析工具
  官网提供了一个分析java内存布局的工具利器 JOT
  [openjdk jot](http://openjdk.java.net/projects/code-tools/jol/)