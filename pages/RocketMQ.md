- `RocketMQ` 是一个**队列模型**的消息中间件，具有**高性能、高可靠、高实时、分布式**的特点。
  它是一个采用 `Java` 语言开发的分布式的消息系统，由阿里巴巴团队开发，在2016年底贡献给 `Apache` ，成为了 `Apache` 的一个顶级项目。 
  在阿里内部， `RocketMQ` 很好地服务了集团大大小小上千个应用，在每年的双十一当天，更有不可思议的万亿级消息通过 `RocketMQ` 流转。
- RocketMQ的消息模型
  `RocketMQ` 中的消息模型就是按照**主题模型**所实现的。 ((62b99489-5b99-41ed-9798-bcdb3a1587e6))
  ![image.png](../assets/image_1656405894302_0.png)
  整个图中有 `Producer Group` 、 `Topic` 、 `Consumer Group` 三个角色`
  1. Producer Group` 生产者组： 代表某一类的生产者，比如我们有多个秒杀系统作为生产者，这多个合在一起就是一个 `Producer Group` 生产者组，它们一般生产相同的消息。`
  2. Consumer Group` 消费者组： 代表某一类的消费者，比如我们有多个短信系统作为消费者，这多个合在一起就是一个 `Consumer Group` 消费者组，它们一般消费相同的消息。`
  3. Topic` 主题： 代表一类消息，比如订单消息，物流消息等等。
  
  生产者组中的生产者会向主题发送消息，而**主题中存在多个队列**，生产者每次生产消息之后是指定主题中的某个队列发送消息的。
  
  每个主题中都有多个队列(分布在不同的 `Broker` 中，如果是集群的话， `Broker` 又分布在不同的服务器中)，集群消费模式下，一个消费者集群多台机器共同消费一个 `topic` 的多个队列，**一个队列只会被一个消费者消费**。如果某个消费者挂掉，分组内其它消费者会接替挂掉的消费者继续消费。就像上图中 `Consumer1` 和 `Consumer2` 分别对应着两个队列，而 `Consumer3` 是没有队列对应的，所以一般来讲要控制**消费者组中的消费者个数和主题中队列个数相同**。
  当然也可以消费者个数小于队列个数，只不过不太建议。如下图。
  ![image.png](../assets/image_1656406210398_0.png)
	- **每个消费组在每个队列上维护一个消费位置**，为什么呢？
	  因为我们刚刚画的仅仅是一个消费者组，我们知道在发布订阅模式中一般会涉及到多个消费者组，而每个消费者组在每个队列中的消费位置都是不同的。如果此时有多个消费者组，那么消息被一个消费者组消费完之后是不会删除的(因为其它消费者组也需要呀)，它仅仅是为每个消费者组维护一个**消费位移(offset)**，每次消费者组消费完会返回一个成功的响应，然后队列再把维护的消费位移加一，这样就不会出现刚刚消费过的消息再一次被消费了。
	  ![image.png](../assets/image_1656406369556_0.png)
	- **为什么一个主题中需要维护多个队列**？
	  答案是**提高并发能力**。的确，每个主题中只存在一个队列也是可行的。你想一下，如果每个主题中只存在一个队列，这个队列中也维护着每个消费者组的消费位置，这样也可以做到**发布订阅模式**。如下图。
- 消费者组消费特点
  1. 集群消费模式下，一个消费者集群多台机器共同消费一个 `topic` 的多个队列，**一个队列只会被一个消费者消费**。
  2. 如果某个消费者挂掉，分组内其它消费者会接替挂掉的消费者继续消费
  3. **每个消费组在每个队列上维护一个消费位置**
- 资料