- 不在并发包之列，提供了思路
  ((6299c26b-666a-4ac1-9ec4-0ddf6b9b2033)) 
  每个线程都绑定自己专属的变量，这样就不存在多线程访问共享变量。
- ThreadLocal
  ThreadLocal
	- 背景知识:
	  四大引用类型 ((6299ed85-5fab-4abb-ad7e-d901f1d30469))
		- 实现原理
		  ThreadLocal以自己this为key,变量为值
		  ![image.png](../assets/image_1654255981331_0.png)
		  如果这张图看懂了，就不必往下看下了
		  1.ThreadLocal的set方法变量存放到哪儿去了?
		  参见Thread的set方法源代码
		  ```java
		  	public void set(T value) {
		          Thread t = Thread.currentThread();
		          ThreadLocalMap map = getMap(t);
		          if (map != null)
		              map.set(this, value);
		          else
		              createMap(t, value);
		      }
		  	ThreadLocalMap getMap(Thread t) {
		          return t.threadLocals;
		      }
		  	static class ThreadLocalMap {
		  
		          static class Entry extends WeakReference<ThreadLocal<?>> {
		              /** The value associated with this ThreadLocal. */
		              Object value;
		  
		              Entry(ThreadLocal<?> k, Object v) {
		                  super(k);
		                  value = v;
		              }
		          }
		  	}
		  ```
		  而Thread类上有ThreadLocal.ThreadLocalMap变量
		  ```java
		  public
		  class Thread implements Runnable {	
		  /* ThreadLocal values pertaining to this thread. This map is maintained
		       * by the ThreadLocal class. */
		      ThreadLocal.ThreadLocalMap threadLocals = null;
		  
		      /*
		       * InheritableThreadLocal values pertaining to this thread. This map is
		       * maintained by the InheritableThreadLocal class.
		       */
		      ThreadLocal.ThreadLocalMap inheritableThreadLocals = null;
		  }
		  ```
		  ThreadLocal的set方法将变量存储到Thread上的ThreadLocal.ThreadLocalMap变量的Entry数组当去中
		  Entry是以ThreadLocal以自己this为key(是个弱引用类型WeakReference),变量为值
		  Thread--->ThreadLocal.ThreadLocalMap--->ThreadLocal.ThreadLocalMap.Entry
	- 缺点
	- 问题:
	- 内存泄漏
	  
	  ThreadLocalMap.Entry的get方法
- netty的FastThreadLocal
- 阿里巴巴的包TransmittableThreadLocal